package common

import (
	"context"
	"path"
	"time"

	"github.com/golang/protobuf/proto"

	"github.com/milvus-io/birdwatcher/proto/v2.0/datapb"
	"github.com/milvus-io/birdwatcher/proto/v2.0/querypb"
	"github.com/milvus-io/birdwatcher/states/kv"
)

const (
	QCDmChannelMetaPrefix    = "queryCoord-dmChannelWatchInfo"
	QCDeltaChannelMetaPrefix = "queryCoord-deltaChannel"
)

func ListQueryCoordDMLChannelInfos(cli kv.MetaKV, basePath string) ([]*querypb.DmChannelWatchInfo, error) {
	ctx, cancel := context.WithTimeout(context.Background(), time.Second*3)
	defer cancel()
	prefix := path.Join(basePath, QCDmChannelMetaPrefix)
	_, vals, err := cli.LoadWithPrefix(ctx, prefix)
	if err != nil {
		return nil, err
	}

	ret := make([]*querypb.DmChannelWatchInfo, 0)
	for _, val := range vals {
		channelInfo := &querypb.DmChannelWatchInfo{}
		err = proto.Unmarshal([]byte(val), channelInfo)
		if err != nil {
			return nil, err
		}
		ret = append(ret, channelInfo)
	}
	return ret, nil
}

func ListQueryCoordDeltaChannelInfos(cli kv.MetaKV, basePath string) ([]*datapb.VchannelInfo, error) {
	ctx, cancel := context.WithTimeout(context.Background(), time.Second*3)
	defer cancel()
	prefix := path.Join(basePath, QCDeltaChannelMetaPrefix)
	_, vals, err := cli.LoadWithPrefix(ctx, prefix)
	if err != nil {
		return nil, err
	}
	ret := make([]*datapb.VchannelInfo, 0, len(vals))
	for _, val := range vals {
		channelInfo := &datapb.VchannelInfo{}
		err = proto.Unmarshal([]byte(val), channelInfo)
		if err != nil {
			return nil, err
		}
		reviseVChannelInfo(channelInfo)
		ret = append(ret, channelInfo)
	}
	return ret, nil
}

// reviseVChannelInfo will revise the datapb.VchannelInfo for upgrade compatibility from 2.0.2
func reviseVChannelInfo(vChannel *datapb.VchannelInfo) {
	removeDuplicateSegmentIDFn := func(ids []int64) []int64 {
		result := make([]int64, 0, len(ids))
		existDict := make(map[int64]bool)
		for _, id := range ids {
			if _, ok := existDict[id]; !ok {
				existDict[id] = true
				result = append(result, id)
			}
		}
		return result
	}

	if vChannel == nil {
		return
	}
	// if the segment infos is not nil(generated by 2.0.2), append the corresponding IDs to segmentIDs
	// and remove the segment infos, remove deplicate ids in case there are some mixed situations
	if vChannel.FlushedSegments != nil && len(vChannel.FlushedSegments) > 0 {
		for _, segment := range vChannel.FlushedSegments {
			vChannel.FlushedSegmentIds = append(vChannel.GetFlushedSegmentIds(), segment.GetID())
		}
		vChannel.FlushedSegments = []*datapb.SegmentInfo{}
	}
	vChannel.FlushedSegmentIds = removeDuplicateSegmentIDFn(vChannel.GetFlushedSegmentIds())

	if vChannel.UnflushedSegments != nil && len(vChannel.UnflushedSegments) > 0 {
		for _, segment := range vChannel.UnflushedSegments {
			vChannel.UnflushedSegmentIds = append(vChannel.GetUnflushedSegmentIds(), segment.GetID())
		}
		vChannel.UnflushedSegments = []*datapb.SegmentInfo{}
	}
	vChannel.UnflushedSegmentIds = removeDuplicateSegmentIDFn(vChannel.GetUnflushedSegmentIds())

	if vChannel.DroppedSegments != nil && len(vChannel.DroppedSegments) > 0 {
		for _, segment := range vChannel.DroppedSegments {
			vChannel.DroppedSegmentIds = append(vChannel.GetDroppedSegmentIds(), segment.GetID())
		}
		vChannel.DroppedSegments = []*datapb.SegmentInfo{}
	}
	vChannel.DroppedSegmentIds = removeDuplicateSegmentIDFn(vChannel.GetDroppedSegmentIds())
}
