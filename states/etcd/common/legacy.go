package common

// import (
// 	"context"
// 	"path"
// 	"time"

// 	"google.golang.org/protobuf/proto"

// 	"github.com/milvus-io/birdwatcher/proto/v2.0/datapb"
// 	"github.com/milvus-io/birdwatcher/proto/v2.0/querypb"
// 	"github.com/milvus-io/birdwatcher/states/kv"
// )

// const (
// 	QCDmChannelMetaPrefix    = "queryCoord-dmChannelWatchInfo"
// 	QCDeltaChannelMetaPrefix = "queryCoord-deltaChannel"
// )

// func ListQueryCoordDMLChannelInfos(cli kv.MetaKV, basePath string) ([]*querypb.DmChannelWatchInfo, error) {
// 	ctx, cancel := context.WithTimeout(context.Background(), time.Second*3)
// 	defer cancel()
// 	prefix := path.Join(basePath, QCDmChannelMetaPrefix)
// 	_, vals, err := cli.LoadWithPrefix(ctx, prefix)
// 	if err != nil {
// 		return nil, err
// 	}

// 	ret := make([]*querypb.DmChannelWatchInfo, 0)
// 	for _, val := range vals {
// 		channelInfo := &querypb.DmChannelWatchInfo{}
// 		err = proto.Unmarshal([]byte(val), channelInfo)
// 		if err != nil {
// 			return nil, err
// 		}
// 		ret = append(ret, channelInfo)
// 	}
// 	return ret, nil
// }

// func ListQueryCoordDeltaChannelInfos(cli kv.MetaKV, basePath string) ([]*datapb.VchannelInfo, error) {
// 	ctx, cancel := context.WithTimeout(context.Background(), time.Second*3)
// 	defer cancel()
// 	prefix := path.Join(basePath, QCDeltaChannelMetaPrefix)
// 	_, vals, err := cli.LoadWithPrefix(ctx, prefix)
// 	if err != nil {
// 		return nil, err
// 	}
// 	ret := make([]*datapb.VchannelInfo, 0, len(vals))
// 	for _, val := range vals {
// 		channelInfo := &datapb.VchannelInfo{}
// 		err = proto.Unmarshal([]byte(val), channelInfo)
// 		if err != nil {
// 			return nil, err
// 		}
// 		reviseVChannelInfo(channelInfo)
// 		ret = append(ret, channelInfo)
// 	}
// 	return ret, nil
// }

// // reviseVChannelInfo will revise the datapb.VchannelInfo for upgrade compatibility from 2.0.2
// func reviseVChannelInfo(vChannel *datapb.VchannelInfo) {
// 	removeDuplicateSegmentIDFn := func(ids []int64) []int64 {
// 		result := make([]int64, 0, len(ids))
// 		existDict := make(map[int64]bool)
// 		for _, id := range ids {
// 			if _, ok := existDict[id]; !ok {
// 				existDict[id] = true
// 				result = append(result, id)
// 			}
// 		}
// 		return result
// 	}

// 	if vChannel == nil {
// 		return
// 	}
// 	// if the segment infos is not nil(generated by 2.0.2), append the corresponding IDs to segmentIDs
// 	// and remove the segment infos, remove deplicate ids in case there are some mixed situations
// 	if vChannel.FlushedSegments != nil && len(vChannel.FlushedSegments) > 0 {
// 		for _, segment := range vChannel.FlushedSegments {
// 			vChannel.FlushedSegmentIds = append(vChannel.GetFlushedSegmentIds(), segment.GetID())
// 		}
// 		vChannel.FlushedSegments = []*datapb.SegmentInfo{}
// 	}
// 	vChannel.FlushedSegmentIds = removeDuplicateSegmentIDFn(vChannel.GetFlushedSegmentIds())

// 	if vChannel.UnflushedSegments != nil && len(vChannel.UnflushedSegments) > 0 {
// 		for _, segment := range vChannel.UnflushedSegments {
// 			vChannel.UnflushedSegmentIds = append(vChannel.GetUnflushedSegmentIds(), segment.GetID())
// 		}
// 		vChannel.UnflushedSegments = []*datapb.SegmentInfo{}
// 	}
// 	vChannel.UnflushedSegmentIds = removeDuplicateSegmentIDFn(vChannel.GetUnflushedSegmentIds())

// 	if vChannel.DroppedSegments != nil && len(vChannel.DroppedSegments) > 0 {
// 		for _, segment := range vChannel.DroppedSegments {
// 			vChannel.DroppedSegmentIds = append(vChannel.GetDroppedSegmentIds(), segment.GetID())
// 		}
// 		vChannel.DroppedSegments = []*datapb.SegmentInfo{}
// 	}
// 	vChannel.DroppedSegmentIds = removeDuplicateSegmentIDFn(vChannel.GetDroppedSegmentIds())
// }
